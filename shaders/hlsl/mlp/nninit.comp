#include "nnutil.h"


Texture2D inputImage : register(t0);
RWTexture2D<float4> resultImage : register(u1);
RWStructuredBuffer<float> weights : register(u2);
RWStructuredBuffer<float> biases : register(u3);
RWStructuredBuffer<int> gradientBiases : register(u4);
RWStructuredBuffer<int> gradientWeights : register(u5);
RWStructuredBuffer<float> adamBiasesMeans : register(u6);
RWStructuredBuffer<float> adamBiasesVariances : register(u7);
RWStructuredBuffer<float> adamWeightsMeans : register(u8);
RWStructuredBuffer<float> adamWeightsVariances : register(u9);

StructuredBuffer<uint> neuronsPerLayer : register(t11);
StructuredBuffer<uint> connectionDataBaseOffsets : register(t12);
StructuredBuffer<uint> neuronDataBaseOffsets : register(t13);

cbuffer globalinfo : register(b10) { NNData globalinfo; }

uint getNeuronDataIndex(uint layer, uint neuron)
{
    return neuronDataBaseOffsets[layer] + neuron;
}

uint getConnectionDataIndex(uint layer, uint neuronFrom, uint neuronTo)
{
    return connectionDataBaseOffsets[layer] + (neuronTo * neuronsPerLayer[layer - 1]) + neuronFrom;
}

[numthreads(16, 16, 1)]
void main(
	int2 groupID : SV_GroupID,
	int2 groupThreadID : SV_GroupThreadID,
	int2 LaunchIndex : SV_DispatchThreadID)
{
    const uint layer = LaunchIndex.x + 1;
    const uint neuron = LaunchIndex.y;
    if (layer >= LAYER_COUNT)
        return;

    uint neuronCountCurrentLayer = neuronsPerLayer[layer];
    uint neuronCountPreviousLayer = neuronsPerLayer[layer - 1];

    if (neuron >= neuronCountCurrentLayer)
        return;
    
    // Initialize bias value to zero
    const uint neuronDataIndex = getNeuronDataIndex(layer, neuron);
    biases[neuronDataIndex] = 0.0f;

    // Initialize Adam optimizer biases data (mean & variance)
    adamBiasesMeans[neuronDataIndex] = 0.0f;
    adamBiasesVariances[neuronDataIndex] = 0.0f;
    
    uint rng = initRNG(LaunchIndex, uint2(LAYER_COUNT, neuronCountCurrentLayer), globalinfo.frameNumber);
    const float xavierWeightScale = xavierUniformScale(rng, neuronCountPreviousLayer, neuronCountCurrentLayer);
    
    // Initialize weights leading to this neuron
    for (uint previousNeuron = 0; previousNeuron < neuronCountPreviousLayer; previousNeuron++)
    {
        const float initialWeight = randInRange(rng, xavierWeightScale);
        const uint weightIndex = getConnectionDataIndex(layer, previousNeuron, neuron);
        weights[weightIndex] = initialWeight;
        
        // Initialize Adam optimizer weights data (mean & variance)
        adamWeightsMeans[weightIndex] = 0.0f;
        adamWeightsVariances[weightIndex] = 0.0f;
    }
}