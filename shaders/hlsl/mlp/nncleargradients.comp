#include "nnutil.h"


Texture2D inputImage : register(t0);
RWTexture2D<float4> resultImage : register(u1);
RWStructuredBuffer<float> weights : register(u2);
RWStructuredBuffer<float> biases : register(u3);
RWStructuredBuffer<int> gradientBiases : register(u4);
RWStructuredBuffer<int> gradientWeights : register(u5);
RWStructuredBuffer<float> adamBiasesMeans : register(u6);
RWStructuredBuffer<float> adamBiasesVariances : register(u7);
RWStructuredBuffer<float> adamWeightsMeans : register(u8);
RWStructuredBuffer<float> adamWeightsVariances : register(u9);

StructuredBuffer<uint> neuronsPerLayer : register(t11);;
StructuredBuffer<uint> connectionDataBaseOffsets : register(t12);;
StructuredBuffer<uint> neuronDataBaseOffsets : register(t13);;

cbuffer globalinfo : register(b10) { NNData globalinfo; }

uint getNeuronDataIndex(uint layer, uint neuron)
{
    return neuronDataBaseOffsets[layer] + neuron;
}

uint getConnectionDataIndex(uint layer, uint neuronFrom, uint neuronTo)
{
    return connectionDataBaseOffsets[layer] + (neuronTo * neuronsPerLayer[layer - 1]) + neuronFrom;
}

[numthreads(16, 16, 1)]
void main(
	int2 groupID : SV_GroupID,
	int2 groupThreadID : SV_GroupThreadID,
	int2 LaunchIndex : SV_DispatchThreadID)
{
    const uint layer = LaunchIndex.x + 1;
    const uint neuron = LaunchIndex.y;
    if (layer >= LAYER_COUNT)
        return;
    
    const uint neuronCountCurrentLayer = neuronsPerLayer[layer];
    const uint neuronCountPreviousLayer = neuronsPerLayer[layer - 1];
    if (neuron >= neuronCountCurrentLayer)
        return;
    
    // Clear bias value
    const uint neuronDataIndex = getNeuronDataIndex(layer, neuron);
    gradientBiases[neuronDataIndex] = 0;

    // Clear weights leading to this neuron
    for (uint previousNeuron = 0; previousNeuron < neuronCountPreviousLayer; previousNeuron++)
    {
        const uint weightIndex = getConnectionDataIndex(layer, previousNeuron, neuron);
        gradientWeights[weightIndex] = 0;
    }
}